MODULE common_letkf
!=======================================================================
!
! [PURPOSE:] Local Ensemble Transform Kalman Filtering (LETKF)
!            Model Independent Core Module
!
! [REFERENCES:]
!  [1] Ott et al., 2004: A local ensemble Kalman filter for atmospheric
!    data assimilation. Tellus, 56A, 415-428.
!  [2] Hunt et al., 2007: Efficient Data Assimilation for Spatiotemporal
!    Chaos: A Local Ensemble Transform Kalman Filter. Physica D, 230,
!    112-126.
!
! [HISTORY:]
!  01/21/2009 Takemasa Miyoshi  Created at U. of Maryland, College Park
!  04/26/2011 Steve Penny converted to OCEAN for use with MOM4
!  09/01/2013 Steve Penny converted adaptive inflation to SFC only
!  10/01/2014 Steve Penny Rewrite to optimize for accuracy and speed 
!                         using symmetric BLAS routines
!
!=======================================================================
!$USE OMP_LIB
  USE common
  USE common_mtx

  IMPLICIT NONE

  PUBLIC
!=======================================================================
!  LEKF Model Independent Parameters
!=======================================================================
  INTEGER,PARAMETER :: nbv=56 !8 !28 !2 !28 !4 !ensemble size

CONTAINS
!=======================================================================
!  Main Subroutine of LETKF Core
!   INPUT
!     nobs             : array size, but only first nobsl elements are used
!     nobsl            : total number of observation assimilated at the point
!     hdxb(nobs,nbv)   : obs operator times fcst ens perturbations
!     rdiag(nobs)      : observation error variance
!     rloc(nobs)       : localization weighting function
!     dep(nobs)        : observation departure (yo-Hxb)
!     parm_infl        : covariance inflation parameter
!   OUTPUT
!     trans(nbv,nbv) : transformation matrix
!=======================================================================
SUBROUTINE letkf_core(nobs,nobsl,hdxb,rdiag,rloc,dep,parm_infl,trans)
  IMPLICIT NONE
  INTEGER,INTENT(IN) :: nobs
  INTEGER,INTENT(IN) :: nobsl
  REAL(r_size),INTENT(IN) :: hdxb(1:nobs,1:nbv)
  REAL(r_size),INTENT(IN) :: rdiag(1:nobs)
  REAL(r_size),INTENT(IN) :: rloc(1:nobs)
  REAL(r_size),INTENT(IN) :: dep(1:nobs)
  REAL(r_size),INTENT(INOUT) :: parm_infl
  REAL(r_size),INTENT(OUT) :: trans(nbv,nbv)
  REAL(r_size) :: hdxb_rinv(nobsl,nbv)
  REAL(r_size) :: eivec(nbv,nbv)
  REAL(r_size) :: eival(nbv)
  REAL(r_size) :: pa(nbv,nbv)
  REAL(r_size) :: work1(nbv,nbv)
  REAL(r_size) :: work2(nbv,nobsl)
  REAL(r_size) :: work3(nbv)
  REAL(r_size) :: work3y(nbv)
  REAL(r_size) :: rho
! REAL(r_size),PARAMETER :: sigma_b = 0.01d0 !(0.001d0 is the 1st and 2nd runs) !error stdev of parm_infl
  !STEVE: I put this in common so I could output it to keep in the records
  INTEGER :: i,j,k, ri,ci
  !STEVE: turn off inflation, but still compute adaptive inflation
  LOGICAL,PARAMETER :: USE_INFL=.true. !STEVE: make this an input argument, and use only for 2d variables
  LOGICAL :: dodebug=.false.
  LOGICAL :: docompare=.false.
  !STEVE: variables to do comparison:
  REAL(r_size) :: hdxb_rinv0(nobsl,nbv)
  REAL(r_size) :: eivec0(nbv,nbv)
  REAL(r_size) :: eival0(nbv)
  REAL(r_size) :: pa0(nbv,nbv)
  REAL(r_size) :: work10(nbv,nbv)
  REAL(r_size) :: work20(nbv,nobsl)
  REAL(r_size) :: work30(nbv)
  REAL(r_size) :: trans0(nbv,nbv)
  REAL(r_size) :: rho0
  REAL(r_size) :: work0(nbv,nbv)
  REAL(r_size) :: eivec1(nbv,nbv)
  REAL(r_size) :: eival1(nbv)

  if (.false.) then
    WRITE(6,*) "!-----------------------------------------------------------------------"
    WRITE(6,*) "!  letkf_core"
    WRITE(6,*) "!-----------------------------------------------------------------------"
  endif

  IF(nobsl == 0) THEN
    trans = 0.0d0
    ! Grow the unobserved area to maintain smoothness in analysis field
    if (USE_INFL) then
      DO i=1,nbv
        trans(i,i) = SQRT(parm_infl)
      END DO
    endif
    RETURN
  ELSE

!!-----------------------------------------------------------------------
!!  hdxb Rinv
!!-----------------------------------------------------------------------
!!-----------------------------------------------------------------------
!!  hdxb^T Rinv hdxb
!!-----------------------------------------------------------------------
!!-----------------------------------------------------------------------
!!  hdxb^T Rinv hdxb + (m-1) I / rho (covariance inflation)
!!-----------------------------------------------------------------------
!
    if (dodebug) then
      WRITE(6,*) "!-----------------------------------------------------------------------"
      WRITE(6,*) "!  hdxb^T Rinv hdxb + (m-1) I / rho "
      WRITE(6,*) "!-----------------------------------------------------------------------"
    endif

    !STEVE: replacing previous 3 sections
    ! Split diagonal matrix into two: sqrt(Rinv)*sqrt(Rinv), and then merge with hdxb:
    DO j=1,nbv
      DO i=1,nobsl
        hdxb_rinv(i,j) = hdxb(i,j) / SQRT(rdiag(i)) * SQRT(rloc(i))
        if (dodebug) then
          WRITE(6,*) "hdxb(",i,",",j,") = ", hdxb(i,j) 
          WRITE(6,*) "rloc(",i,") = ", rloc(i)
          WRITE(6,*) "rdiag(",i,") = ", rdiag(i)
          WRITE(6,*) "SQRT(rloc(",i,") / rdiag(",i,")) = ", SQRT(rloc(i) / rdiag(i))
          WRITE(6,*) "SQRT(rdiag(",i,")) * SQRT(rloc(",i,")) = ", SQRT(rdiag(i)) * SQRT(rloc(i))
          WRITE(6,*) "hdxb rinv(",i,",",j,") = hdxb(",i,",",j,") * SQRT(rloc(",i,") / rdiag(",i,"))"
          WRITE(6,*) "hdxb rinv(",i,",",j,") = ", hdxb(i,j) / SQRT(rloc(i) / rdiag(i))
          WRITE(6,*) "hdxb_rinv(",i,",",j,") = hdxb(",i,",",j,") / SQRT(rdiag(",i,")) * SQRT(rloc(",i,"))"
          WRITE(6,*) "hdxb_rinv(",i,",",j,") = ", hdxb_rinv(i,j)
        endif
      END DO
    END DO

    ! Form identity matrix:
    work1 = 0.0d0
    DO i=1,nbv
      work1(i,i) = 1.0d0 
    END DO

    rho = REAL(nbv-1,r_size)/parm_infl
!   STEVE: add Identity times ensemble size and inflation here:
!   CALL dsyrk( 'L','T',nbv,nobsl,1.0d0,hdxb_rinv,nbv, rho,work1,nbv)
!   STEVE: add Identity times ensemble size and inflation later:
    CALL dsyrk( 'L','T',nbv,nobsl,1.0d0,hdxb_rinv,nobsl, 0.0d0,work1,nbv)

    if (dodebug) then
      WRITE(6,*) "Post-dsyrk:: work1 = ", work1
    endif

    ! Then fill in the strictly upper diagonal part with the entries from the lower diagonal:
    do ri=1,nbv
      do ci=ri+1,nbv
        if (dodebug) WRITE(6,*) "before flip, work1(",ri,",",ci,") = ", work1(ri,ci)
        work1(ri,ci) = work1(ci,ri)
        if (dodebug) WRITE(6,*) " after flip, work1(",ri,",",ci,") = ", work1(ri,ci)
      enddo
    enddo

    !!!!!!!!!!!!
    ! Compare
    !!!!!!!!!!!!
    if (docompare) then
      DO j=1,nbv
        DO i=1,nobsl
          hdxb_rinv0(i,j) = hdxb(i,j) / rdiag(i) * rloc(i)
        END DO
      END DO
      CALL dgemm('t','n',nbv,nbv,nobsl,1.0d0,hdxb_rinv0,nobsl,hdxb(1:nobsl,:),nobsl,0.0d0,work10,nbv)
      do ri=1,nbv
        if (dodebug) WRITE(6,*) " after, work1(",ri,",",ri,")  = ", work1(ri,ri)
        if (dodebug) WRITE(6,*) " after, work10(",ri,",",ri,") = ", work10(ri,ri)
        do ci=ri+1,nbv
          if (dodebug) WRITE(6,*) " after, work1(",ri,",",ci,")  = ", work1(ri,ci)
          if (dodebug) WRITE(6,*) " after, work10(",ri,",",ci,") = ", work10(ri,ci)
        enddo
      enddo

    endif

!-----------------------------------------------------------------------
!  eigenvalues and eigenvectors of [ hdxb^T Rinv hdxb + (m-1) I ]
!-----------------------------------------------------------------------
    !STEVE: adding Identity times inflation and ensemble size here for now (prefer to do it earlier)
    rho0 = 1.0d0 / parm_infl
    DO i=1,nbv
      work1(i,i) = work1(i,i) + REAL(nbv-1,r_size) * rho0
    END DO

    CALL mtx_eigen(1,nbv,work1,eival,eivec,i)

!   if (dodebug) then
!     WRITE(6,*) "eival = ", eival
!     WRITE(6,*) "eivec = ", eivec
!   endif

!   if ( MINVAL(eival) .le. 0.0 ) then
!     print *, "common_letkf.f90:: ERROR: matrix eigenvalue â‰¤ 0"
!     print *, "eival = ", eival
!     print *, "nbv = ", nbv
!     print *, "i = ", i
!     stop 1
!   endif

    !!!!!!!!!!!!
    ! Compare
    !!!!!!!!!!!!
    if (docompare) then
      rho0 = 1.0d0 / parm_infl
      DO i=1,nbv
        work10(i,i) = work10(i,i) + REAL(nbv-1,r_size) * rho0
      END DO
      CALL mtx_eigen(1,nbv,work10,eival0,eivec0,i)

      !TEST
      work0 = ( work10 + TRANSPOSE(work10) )/2.0d0
      if (MAXVAL(abs(work10 - TRANSPOSE(work10))) > 0.0d0) then
        WRITE(6,*) "common_letkf.f90:: ERROR: the argument to the eigenvalue decomposition is not symmetric." 
        WRITE(6,*) "work10 = ", work10
        WRITE(6,*)  "work0  = ", work0
        WRITE(6,*)  "abs(work0 - work10) = ", abs(work0 - work10)
!       WRITE(6,*) "EXITING..."
!       stop 385 
      endif

      CALL mtx_eigen(1,nbv,work0,eival1,eivec1,i)

      DO i=1,nbv
        if (dodebug) then
          WRITE(6,*) "post mtx_eigen, eival(",i,")  = ", eival(i)
          WRITE(6,*) "post mtx_eigen, eival0(",i,") = ", eival0(i)
          WRITE(6,*) "post mtx_eigen, eival1(",i,") = ", eival1(i)
        endif
      END DO

    endif

!-----------------------------------------------------------------------
!  Pa = [ hdxb^T Rinv hdxb + (m-1) I ]inv
!-----------------------------------------------------------------------
    if (dodebug) then
      WRITE(6,*) "!-----------------------------------------------------------------------"
      WRITE(6,*) "!  Pa = [ hdxb^T Rinv hdxb + (m-1) I ]inv"
      WRITE(6,*) "!-----------------------------------------------------------------------"
    endif
    eival = SQRT(eival)
    DO j=1,nbv
      DO i=1,nbv
        work1(i,j) = eivec(i,j) / eival(j)
        if (dodebug) then
          WRITE(6,*) "post evec/sqrt(eval), work1(",i,",",j,") = ", work1(i,j)
        endif
      END DO
    END DO

    ! CALL dgemm('n','t',nbv,nbv,nbv,1.0d0,work1,nbv,eivec,nbv,0.0d0,pa,nbv)
    !STEVE: ensure that Pa is symmetric:
    CALL dsyrk( 'L','T',nbv,nbv,1.0d0,work1,nbv, 0.0d0,pa,nbv )
    ! Then fill in the strictly upper diagonal part with the entries from the lower diagonal:
    ! NOTE: since using a symmetric BLAS routine below, we don't actually need to fill pa in...
    if (dodebug .and. .false.) then
    do ri=1,nbv
!     if (dodebug) WRITE(6,*) "pa(",ri,",",ri, ") = ", pa(ri,ri)
      do ci=ri+1,nbv
        pa(ri,ci) = pa(ci,ri)
!       if (dodebug) then
!         WRITE(6,*) "pa(",ri,",",ci, ") = ", pa(ri,ci)
!       endif
      enddo
    enddo
    endif

    !!!!!!!!!!!!
    ! Compare
    !!!!!!!!!!!!
    if (docompare) then
      DO j=1,nbv
        DO i=1,nbv
          work10(i,j) = eivec0(i,j) / eival0(j)
        END DO
      END DO
      CALL dgemm('n','t',nbv,nbv,nbv,1.0d0,work10,nbv,eivec0,nbv,0.0d0,pa0,nbv)
      do ri=1,nbv
        if (dodebug) WRITE(6,*) "pa(",ri,",",ri, ")  = ", pa(ri,ri)
        if (dodebug) WRITE(6,*) "pa0(",ri,",",ri, ") = ", pa0(ri,ri)
        do ci=ri+1,nbv
          if (dodebug) then
            WRITE(6,*) "pa(",ri,",",ci, ")  = ", pa(ri,ci)
            WRITE(6,*) "pa0(",ri,",",ci, ") = ", pa0(ri,ci)
          endif
        enddo
      enddo
    endif

!-----------------------------------------------------------------------
!  T = sqrt[(m-1)Pa]
!-----------------------------------------------------------------------
    if (dodebug) then
      WRITE(6,*) "!-----------------------------------------------------------------------"
      WRITE(6,*) "!  T = sqrt[(m-1)Pa]"
      WRITE(6,*) "!-----------------------------------------------------------------------"
    endif
    eival = 1.0d0/SQRT(eival)
    DO j=1,nbv
      DO i=1,nbv
        work1(i,j) = eivec(i,j) * eival(j)
        if (dodebug) then
          WRITE(6,*) "work1(",i,",",j,") = ", work1(i,j)
        endif
      END DO
    END DO

    ! CALL dgemm('n','t',nbv,nbv,nbv,1.0d0,work1,nbv,eivec,nbv,0.0d0,trans,nbv)
    !STEVE: ensure that sqrt(Pa) is symmetric:
    CALL dsyrk( 'L','T',nbv,nbv,1.0d0,work1,nbv, 0.0d0,trans,nbv )

    ! Then fill in the strictly upper diagonal part with the entries from the lower diagonal:
    do ri=1,nbv
      if (dodebug) WRITE(6,*) "trans(",ri,",",ri,") = ", trans(ri,ri)
      do ci=ri+1,nbv
        trans(ri,ci) = trans(ci,ri)
        if (dodebug) then
          WRITE(6,*) "trans(",ri,",",ci,") = ", trans(ri,ci)
        endif
      enddo
    enddo

!-----------------------------------------------------------------------
!  Pa hdxb_rinv^T
!-----------------------------------------------------------------------
    !!!!!!!!!!!!
    ! Compare
    !!!!!!!!!!!!
    if (docompare) then
      CALL dgemm('n','t',nbv,nobsl,nbv,1.0d0,pa0,nbv,hdxb_rinv0,nobsl,0.0d0,work20,nbv)
    endif

!-----------------------------------------------------------------------
!  Pa hdxb_rinv^T dep
!-----------------------------------------------------------------------
    !STEVE: better to multiply hdxb_rinv^T dep, then Pa (hdxb_rinv^T dep)
    if (dodebug) then
      WRITE(6,*) "!-----------------------------------------------------------------------"
      WRITE(6,*) "!  Pa hdxb_rinv^T dep"
      WRITE(6,*) "!-----------------------------------------------------------------------"
    endif
    !STEVE: added this in here to make up for earlier change to hdxb_rinv
    DO j=1,nbv
      DO i=1,nobsl
        hdxb_rinv(i,j) = hdxb(i,j) / rdiag(i) * rloc(i)
      END DO
    END DO
!   CALL dgemv ('t', nbv, nobsl, 1.0d0, hdxb_rinv, nobsl, dep(1:nobsl), 1, 0.0d0, work3, 1)
!   CALL dgemv ('t', nbv, nobsl, 1.0d0, hdxb_rinv, nbv, dep(1:nobsl), 1, 0.0d0, work3, 1)
    CALL dgemv ('t', nobsl, nbv, 1.0d0, hdxb_rinv, nobsl, dep(1:nobsl), 1, 0.0d0, work3y, 1)
    if (dodebug) then
!     if (dodebug) WRITE(6,*) "dep = ", dep(1:nobsl)
!     if (dodebug) WRITE(6,*) "work3y = ", work3y
    endif

    CALL dsymv ('L', nbv, 1.0d0, pa, nbv, work3y, 1, 0.0d0, work3, 1)
    if (dodebug) then
      if (dodebug) WRITE(6,*) "work3y = ", work3y
      if (dodebug) WRITE(6,*) "work3  = ", work3
    endif

    !!!!!!!!!!!!
    ! Compare
    !!!!!!!!!!!!
    if (docompare) then
      DO i=1,nbv
        work30(i) = work20(i,1) * dep(1)
        DO j=2,nobsl
          work30(i) = work30(i) + work20(i,j) * dep(j)
        END DO
      END DO
      if (dodebug) WRITE(6,*) "work30 = ", work30
    endif

!-----------------------------------------------------------------------
!  T + Pa hdxb_rinv^T dep
!-----------------------------------------------------------------------
    if (dodebug) then
      WRITE(6,*) "!-----------------------------------------------------------------------"
      WRITE(6,*) "!  T + Pa hdxb_rinv^T dep"
      WRITE(6,*) "!-----------------------------------------------------------------------"
    endif
    DO j=1,nbv
!     if (dodebug) WRITE(6,*) "before: trans(:,j) = ", trans(:,j)
      trans(:,j) = trans(:,j) + work3(:)
!     if (dodebug) WRITE(6,*) " after: trans(:,j) = ", trans(:,j)
    END DO

    !!!!!!!!!!!!
    ! Compare
    !!!!!!!!!!!!
    if (docompare) then
      DO j=1,nbv
        DO i=1,nbv
          trans0(i,j) = trans0(i,j) + work30(i)
          if (dodebug) WRITE(6,*) " after: trans(",i,",",j,")  = ", trans(i,j)
          if (dodebug) WRITE(6,*) " after: trans0(",i,",",j,") = ", trans0(i,j)
        END DO
      END DO
    endif

    !STEVE: testing...
    if (dodebug) then
      WRITE(6,*) "EXITING... (on purpose in letkf_core: 1984)"
      STOP(1984)
    endif

    return

  ENDIF
END SUBROUTINE letkf_core

END MODULE common_letkf
